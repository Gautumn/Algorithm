# 参考：

1. [修电脑的龙生](https://www.cnblogs.com/longjin2018/default.html?page=12)

# 练习

### 2.1.1 TODO:

### 2.1.2 在选择排序中，一个元素最多可能会被交换多少次？平均可能会被交换多少次？
```
4 1 2 3 // 待排序
1 4 2 3
1 2 4 3
1 2 3 4
这里元素4被移动了n-1次
```
### 2.1.3 构造一个含有N个元素的数组，使选择排序(算法2.1）运行过程中a[j] < a[min]成功的次数最大
``` C++
// 算法2.1 选择排序
void sort(Comparable[] a) {
    int N = a.length;
    for (int i = 0; i < N; i++) {
        int min = i;
        for (int j = i + 1; j < N; j++)
            if (less(a[j], a[min])) min = j;
        exch(a, i, min);
    }
}

// a[j] < a[min] 成立的次数多，那么表示要经常更新min值，那么只有数组完全倒序的情况下才可以。
```
### 2.1.4 TODO：

### 2.1.5 构造一个含有N个元素的数组，是插入排序（算法2.2）运行过程中内循环（for)的两个判断结果总是假
``` C++
// 算法2.2 插入排序
void sort(Comparable[] a) {
    int N = a.length;
    for (int i = 1; i < N; i++) {
        for (int j = i; j > 0 && less(a[j], a[j - 1]); j--)
            exch(a, j, j - 1);
    }
}
// 应该是表达式less(a[j], a[j - 1])总是假的，即a[j] >= a[j - 1]. 那么只要这个数列是排好序的，或者有相同的主键就可以了。
```

### 2.1.6 在所有的主键都相同时，选择排序和插入排序谁更快？
主键都相同时，选择排序依然要比较N^2次，而插入排序则只需要比较N次。所以插入排序更快

### 2.1.7 对于逆序数组，选择排序和插入排序谁更快？
- 选择：比较次数是N^2/2，交换次数是N
- 插入：比较次数是N^2/2，交换次数是N^2/2
``` C++
// N = 4
4 3 2 1 // 待排序

3 4 2 1 // 比较一次，交换一次

3 2 4 1
2 3 4 1 // 比较两次，交换两次

2 3 1 4
2 1 3 4
1 2 3 4 // 比较三次，交换三次

```
- 结论：选择排序会更加快速，也从此可以看出插入排序更适合部分有序的情况，并且交换的代价要比较小的情况（当然，操作指针可以避免赋值的开销）。

### 2.1.8 假设元素只可能有三种值，使用插入排序处理这样一个随机数组成的运行时间是线性的还是平方级别的？或者介于两者之间？
介于两者之间
``` C++
// 三种元素：1，2，3，三种元素各有2个

3 3 2 2 1 1  // 最坏情况，待排序

3 2 3 2 1 1
2 3 3 2 1 1

2 3 2 3 1 1
2 2 3 3 1 1  // 两个2要放到3前面，需要2*2次比较，2*2次交换

2 2 3 1 3 1
2 2 1 3 3 1
2 1 2 3 3 1
1 2 2 3 3 1

1 2 2 3 1 3
1 2 2 1 3 3
1 2 1 2 3 3
1 1 2 2 3 3 // 两个1放到2和3前面，需要2*4次比较，2*4次交换

假设三种元素有N个，每种平均N/3个，排序为3(N/3个)2(N/3个)1(N/3个）
2放到3前面需要N/3 * N/3 = N^2/9次比较和交换
1放到2和3前面需要(N/3 + N/3) * N/3 = 2N^2/9次比较和交换
总次数为：N^2 / 3
```

### 2.1.9 TODO:
### 2.1.10 在希尔排序中为什么在实现h有序时不使用选择排序？
平均情况下，部分有序使用插入排序会更加快捷。h有序的情况下，数组有序的概率会更高(每组的元素数量小)。当h不断减小时，数组本身也会更加有序。

### 2.1.11 将希尔排序中实时计算递增序列改为预先计算并存储在一个数组中
``` C++
void sort(Comparable[] a) {
    int N = a.length;
    int h = 1;
    while (h < N / 3>) h = h * 3 + 1 // 1, 4, 13, 40, 121
    while (h > 0) {
        for (int i = h; i < N, i++) {
            for (int j = i; j >= h && a[j] < a[j - 1]; j -= h)
                exch(a, j, j-1);
        }
        h = h / 3;
    }
}
// ===========================================================
void sort(Comparable[] a) {
    int N = a.length;
    int h;
    // 其实已经计算出了需要用到的h序列，这里用C++了哈
    std::vector<int> hv{1};
    while (hv.back() < N / 3>) hv.push_back(hv.back() * 3 + 1);// 1, 4, 13, 40, 121

    for(auto it = hv.rbegin(); it != hv.rend(); it++) {
        h = *it;
        for (int i = h; i < N, i++) {
            for (int j = i; j >= h && a[j] < a[j - 1]; j -= h)
                exch(a, j, j-1);
        }
    }
}


```
### 2.1.12 令希尔排序打印出递增序列的每个元素所带来的的比较次数和数组大小的比值。编写一个测试用例对随机Double数组进行希尔排序，验证该值是一个小常数，数组大小按照10的幂次递增，不小于100.
``` C++
void frandom(std::vector<double> &v, size_t size) {
    static std::default_random_engine e;
    static std::uniform_real_distribution<double> u(0, 1000);
    for (size_t i = 0; i < size; i++) {
        v.push_back(u(e));
    }
}
static int fcompCount = 0;
bool fcomp (const double &l, const double &r) {
    fcompCount++;
    return l < r;
}

void getShellCompCount(const int &n, int &count) {
    std::vector<double> vp;
    frandom(vp, n);
    fcompCount = 0;
    shellSort(vp.begin(), vp.end(), fcomp);
    count = fcompCount;
}

void practise_2_1_12() {

    int count = 0;
    // 100个
    getShellCompCount(100, count);
    std::cout << "size: " << 100 << " compare: " << fcompCount << '\n'; // 742
    // 1000个
    getShellCompCount(1000, count);
    std::cout << "size: " << 1000 << " compare: " << fcompCount << '\n'; // 14520
    // 10000个
    getShellCompCount(10000, count);
    std::cout << "size: " << 10000 << " compare: " << fcompCount << '\n'; // 233224
    // 1000000个
    getShellCompCount(1000000, count);
    std::cout << "size: " << 1000000 << " compare: " << fcompCount << '\n'; // 64505994

    // 100000000个(1亿）
    // getShellCompCount(100000000, count);
    // std::cout << "size: " << 100000000 << " compare: " << fcompCount << '\n';
}
```




# 提高题
### 2.1.13 纸牌排序。
感觉希尔排序好像更合适

### 2.1.14 出列排序。说说你会如何将一副扑克牌排序，限制条件是只能查看最上面的两张牌，交换最上面的两张牌，或是将最上面的一张牌放到这摞牌的最下面。
思路，比较前两个，
- 前面 >= 后面，前面的放到最后
- 前面 <  后面，交换二者
```
2 3 1 // 初始
3 2 1
2 1 3
1 3 2
3 1 2
1 2 3
```

### 2.1.15 昂贵的交换。一家货运公司的一位职员得到了一项任务，需要将若干大货箱按照发货时间摆放。比较发货时间很容易（对照标签即可），但将两个货箱交换位置则很困难（移动麻烦）。仓库已经快满了，只有一个空闲的仓位。这位职员应该使用哪种排序算法呢？

比较容易，交换麻烦的使用: 选择排序

### 2.1.19希尔排序的最坏情况。用1到100构造一个含有100个元素的数组并用希尔排序和递增序列1、4 、13 、40对其排序，使比较的次数尽可能多。

次数尽可能多，因为希尔的h有序使用的是插入排序，那么插入排序的最坏情况是倒叙
100个数，h可以取值范围：1, 4, 13, 40
h=1 递增
h=4 递增
h=13 递增
h=40 递增

``` C++
TODO:
```

### 2.1.21可比较的交易。用我们的Date类(请见2.1.1.4节)作为模板扩展你的Transaction类(请见练习1.2.13)，实现Comparable接口，使交易能够按照金额排序。

C++ 在sort的时候可以自定义一个比较函数，或者为类重载一个"<"运算符


****** 识别结果 1******

2．114出列排序。说说你会如何将一副扑克牌排序，限制条件是只能查看最上面的两张牌，交换最上
面的两张牌，或是将最上面的一张牌放到这摞牌的最下面。
