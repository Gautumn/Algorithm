### 练习

#### 2.1.1 TODO:

#### 2.1.2 在选择排序中，一个元素最多可能会被交换多少次？平均可能会被交换多少次？
```
4 1 2 3 // 待排序
1 4 2 3
1 2 4 3
1 2 3 4
这里元素4被移动了n-1次
```
#### 2.1.3 构造一个含有N个元素的数组，使选择排序(算法2.1）运行过程中a[j] < a[min]成功的次数最大
``` C++
// 算法2.1 选择排序
void sort(Comparable[] a) {
    int N = a.length;
    for (int i = 0; i < N; i++) {
        int min = i;
        for (int j = i + 1; j < N; j++)
            if (less(a[j], a[min])) min = j;
        exch(a, i, min);
    }
}

// a[j] < a[min] 成立的次数多，那么表示要经常更新min值，那么只有数组完全倒序的情况下才可以。
```
#### 2.1.4 TODO：

#### 2.1.5 构造一个含有N个元素的数组，是插入排序（算法2.2）运行过程中内循环（for)的两个判断结果总是假
``` C++
// 算法2.2 插入排序
void sort(Comparable[] a) {
    int N = a.length;
    for (int i = 1; i < N; i++) {
        for (int j = i; j > 0 && less(a[j], a[j - 1]); j--)
            exch(a, j, j - 1);
    }
}
// 应该是表达式less(a[j], a[j - 1])总是假的，即a[j] >= a[j - 1]. 那么只要这个数列是排好序的，或者有相同的主键就可以了。
```

#### 2.1.6 在所有的主键都相同时，选择排序和插入排序谁更快？
主键都相同时，选择排序依然要比较N^2次，而插入排序则只需要比较N次。所以插入排序更快

#### 2.1.7 对于逆序数组，选择排序和插入排序谁更快？
- 选择：比较次数是N^2/2，交换次数是N
- 插入：比较次数是N^2/2，交换次数是N^2/2
``` C++
// N = 4
4 3 2 1 // 待排序

3 4 2 1 // 比较一次，交换一次

3 2 4 1
2 3 4 1 // 比较两次，交换两次

2 3 1 4
2 1 3 4
1 2 3 4 // 比较三次，交换三次

```
- 结论：选择排序会更加快速，也从此可以看出插入排序更适合部分有序的情况，并且交换的代价要比较小的情况（当然，操作指针可以避免赋值的开销）。

#### 2.1.8 假设元素只可能有三种值，使用插入排序处理这样一个随机数组成的运行时间是线性的还是平方级别的？或者介于两者之间？
```
三种元素：1，2，3，三种元素各有2个

3 3 2 2 1 1  // 最坏情况，待排序

3 2 3 2 1 1
2 3 3 2 1 1

2 3 2 3 1 1
2 2 3 3 1 1  // 两个2要放到3前面，需要2*2次比较，2*2次交换

2 2 3 1 3 1
2 2 1 3 3 1
2 1 2 3 3 1
1 2 2 3 3 1

1 2 2 3 1 3
1 2 2 1 3 3
1 2 1 2 3 3
1 1 2 2 3 3 // 两个1放到2和3前面，需要2*4次比较，2*4次交换

假设三种元素有N个，每种平均N/3个，排序为3(N/3个)2(N/3个)1(N/3个）
2放到3前面需要N/3 * N/3 = N^2/9次比较和交换
1放到2和3前面需要(N/3 + N/3) * N/3 = 2N^2/9次比较和交换
总次数为：N^2 / 3
```

2 2 1 3 1 3
2


